# Java编码规范
created at 2015-06-01

本文档翻译自http://google-styleguide.googlecode.com/svn/trunk/javaguide.html

本文档参考自http://www.hawstein.com/posts/google-java-style.html

## 目录
* [1 前言](#1)
  * [1.1 术语说明](#a)
  * [1.2 指南说明](#102)
* [2 源文件基本设置](#2)
  * [2.1 文件名](#201)
  * [2.2 文件编码: UTF-8](#202)
  * [2.3 特殊字符](#203)
* [3 源文件结构](#3)
  * [3.1 许可证或者版权信息](#301)
  * [3.2 包名语句](#302)
  * [3.3 import语句](#303)
  * [3.4 类声明](#304)
* [4 格式](#4)
  * [4.1 大括号](#401)
  * [4.2 块代码缩进](#402)
  * [4.3 一行一个语句](#403)
  * [4.4 列长度限制:80 or 100](#404)
  * [4.5 换行](#405)
  * [4.6 空格](#406)
  * [4.7 小括号分组](#407)
  * [4.8 特定的结构体](#408)
* [5 命名约定](#5)
  * [5.1 对所有标识符都通用的规则](#501)
  * [5.2 适用于某些标识符类型的规则](#502)
  * [5.3 驼峰式命名](#503)
* [6 编程实践](#6)
  * [6.1 @Override: 总是使用](#601)
  * [6.2 异常捕获:不能忽略](#602)
  * [6.3 静态成员:使用类进行调用](#603)
  * [6.4 Finalizers:勿用](#604)
* [7 Javadoc](#7)
  * [7.1 格式](#701)
  * [7.2 摘要片段](#702)
  * [7.3 需要用到Javadoc的地方](#703)
* [8 样例](#8)

<a name="1"> </a>
## 1 前言
这份文档是Google Java编程风格规范的完整定义。当且仅当一个Java源文件符合此文档中的规则， 我们才认为它符合Google的Java编程风格。

与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题， 同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则， 对于那些不是明确强制要求的，我们尽量避免提供意见。

_译者注：我们的代码风格并非完全遵循Google的Java风格！因此本文与原文有部分不同之处！_
<a name="a"> </a>
#### 1.1 术语说明
在本文档中，除非另有说明：

1. 术语 _class_ 可表示一个"普通"类，枚举类，接口或是annotation类型(@interface)
2. 术语 _comment_ 只用来指代代码实现的注释(_implementation_ comments)，我们不使用文档注释("documentation comments")一词，而是用Javadoc。

其他的”术语说明“会偶尔在后面的文档出现。

<a name="102"> </a>
#### 1.2 指南说明
本文档中的示例代码并不作为规范。意味着，虽然示例代码是遵循Google Java编程风格，但并不是说这是展现这些代码的唯一风格。 示例中的格式选择不应该被强制定为规则。

<a name="2"> </a>
## 2 源文件基本设置
<a name="201"> </a>
#### 2.1 文件名
源文件以其最顶层的类名来命名，大小写敏感，文件扩展名为.java。

<a name="202"> </a>
#### 2.2 文件编码: UTF-8
源文件编码格式为UTF-8

_译者注：可以通过IDE来确认和设置，怎么设置可百度_

<a name="203"> </a>
#### 2.3 特殊字符

__2.3.1 空格__

除了行结束符序列，ASCII水平空格字符(0x20，即空格)是源文件中唯一允许出现的空白字符，这意味着：

1. 所有其它字符串中的空白字符都要进行转义。
2. 制表符不用于缩进。

_译者注：一般来说IDE会自动将tab转换成4个空格，这个也是可以在IDE里面设置的_

__2.3.2 特殊转义字符__

对于具有特殊转义序列的任何字符(\b, \t, \n, \f, \r, \“, \‘及\\)，我们使用它的转义序列，而不是相应的八进制(比如\012)或Unicode(比如\u000a)转义。

__2.3.2 非ASCII字符__

对于剩余的非ASCII字符，是使用实际的Unicode字符(比如∞)，还是使用等价的Unicode转义符(比如\u221e)，都取决于哪个能让代码__更易于阅读和理解__。
>Tip: 在使用Unicode转义符或是一些实际的Unicode字符时，写一些解释性的注释会很有帮助

比如：

| 示例 | 评价  | 
| :------------ |:----------------|
| String unitAbbrev = "统一码";                                             | 赞，即使没有注释也非常清晰 |
| String unitAbbrev = "\u7edf\u4e00\u7801"; // "统一码"                     | 允许，但没有理由要这样做        |
| String unitAbbrev = "\u7edf\u4e00\u7801"; // Chinise letter for "unicode" | 允许，但这样做显得笨拙还容易出错        |
| String unitAbbrev = "\u7edf\u4e00\u7801";                                 | 很糟，读者根本看不出这是什么 |
| return '\ufeff' + content; // byte order mark                             | Good，对于非打印字符，使用转义，并在必要时写上注释 |
>Tip: 永远不要出于害怕某些程序可能无法正确处理非ASCII字符而让你的代码可读性变差。当程序无法正确处理非ASCII字符时，它自然无法正确运行，那就需要去修复这些问题了。(言下之意就是大胆去用非ASCII字符，如果真的有需要的话)

<a name="3"> </a>
## 3 源文件结构
一个源文件包含(按顺序地)：

1. 许可证或版权信息，如有需要
2. package语句
3. import语句
4. 有且仅有一个顶级类

以上各个部分之间用一个空行隔开。

<a name="301"> </a>
#### 3.1 许可证或者版权信息
如果一个文件包含许可证或版权信息，那么它应当被放在文件内的最前面。

<a name="302"> </a>
#### 3.2 包名语句
package语句不换行，列限制([4.4 列长度限制:80 or 100](#404))不适用于package语句。

_译者注：即package语句写在一行里_

<a name="303"> </a>
#### 3.3 import语句

__3.3.1 不要使用通配符__

无论是静态引用(static)还是非静态引用，都不要使用通配符。

_译者注：类似于import java.util.*;_

__3.3.2 不要换行__

import语句不换行，列限制([4.4 列长度限制:80 or 100](#404))不适用于import语句。

__3.3.3 顺序和间距__

import语句可分为以下几组，按照这个顺序，各组之间用一个空行分隔：

1. 所有的静态引用(static imports)放到单独一个组里
2. com.google imports(仅当这个源文件是在com.google包下)
3. 第三方的包，每一个顶级包为一组，字典序
   * 比如：android, com, junit, org, sun
4. java imports
5. javax imports
组内不空行，按字典序排列（注意：排序时请忽视分号";"）。

_译者注：关于第二条，如在我们微博就是com.weibo的引用单独归到一个组里，可不遵循_

<a name="304"> </a>
#### 3.4 类声明

__3.4.1 有且仅有一个顶级类__

各个顶级类都应该只在于它自己的源文件中（即同名文件中，忽视.java后缀）

_译者注：例外：package-info.java，该文件中可没有package-info类_

__3.4.2 类成员顺序__

类的成员顺序对类的易学性有很大的影响，但是也不存在唯一正确的指南来指导我们怎么做。不同的类对成员的排序可能是不同的。

重要的是各个类用其特定的排序逻辑，该类的维护者要能够解释其排序逻辑。比如，新的方法不能只是习惯性的添加到类的最后面，这会使得排序规则变成了按时间排序而不是某种逻辑排序。

__3.4.2.1 重载：永不拆分__

当一个类有多个构造函数，或是多个同名方法，这些函数/方法应该依次地出现，中间不要插入其它函数/方法。

<a name="4"> </a>
## 4 格式
__术语说明：__块状结构(block-like construct)指的是一个类、方法或构造函数的主体。需要注意的是，(4.8.3.1节)数组初始化中的初始值可被选择性地视为块状结构。

<a name="401"> </a>
#### 4.1 大括号

__4.1.1 尽量使用大括号__

大括号用于```if```, ```else```, ```for```, ```do```和```while```，即使主体为空或者只有一行代码，也要使用大括号。

__4.1.2  非空块：K & R 风格__

对于非空块和块状结构，大括号遵循Kernighan和Ritchie风格 (Egyptian brackets):
* 左大括号前不换行
* 左大括号后换行
* 右大括号前换行
* 如果右大括号是一个语句、函数体或类的结尾，则右大括号后换行; 否则不换行。例如，如果右大括号后面是```else```或分号，则不换行。

```java
return new MyClass() {
    @Override public void method() {
        if (condition()) {
            try {
                something();
            } catch (ProblemException e) {
                recover();
            }
        }
    }
};
```

4.8.1节，enum类部分给出了的一些例外情况。

__4.1.3  空块：可采用简洁风格__

一个空的块或块状结构里右大括号可以紧跟左大括号，不要在(```{}```)插入空格或者换行,除非它是一个多块语句(```if/else``` 或 ```try/catch/finally```)的一部分 ，即使大括号内没内容，右大括号也要换行。

示例：
```
void doNothing() {}
```

<a name="402"> </a>
#### 4.2 块代码缩进

每当开始一个新的块或块状结构，缩进增加4个空格，当块结束时，缩进回到先前的缩进级别。缩进级别适用于整个块内的代码和注释。(见4.1.2节中的代码示例)

<a name="403"> </a>
#### 4.3 一行一句代码
每个语句后要换行。

<a name="404"> </a>
#### 4.4 列长度限制:80 or 100
一个项目可以选择一行80个字符或100个字符的列限制，除了下述例外，任何一行如果超过这个字符数限制，必须换行，如4.5节所示。
__例外：__

1. 不可能满足列限制的行(例如，Javadoc中的一个长URL，或是一个长的JSNI方法参考)。
2. package和import声明(见3.2节和3.3节)。
3. 注释中那些可能被剪切并粘贴到shell中的命令行。

<a name="405"> </a>
#### 4.5 换行
__术语说明：__当代码不能被合法地写成一行（通常是为了避免超出列限制）而被划分成多行时，我们称之为_换行_。

不存在全面的、明确的公式来指明在每一种情况下如何换行。很多时候，对于同一段代码会有多种换行方式。

>Tip: 提取方法或局部变量可以在不换行的情况下解决代码过长的问题(合理缩短命名长度？)。

__4.5.1  断行的位置__

换行的基本准则是：更倾向于在更高的语法级别处断开。并且：
1. 如果断行处是在_非赋值运算符_前后，则在该运算符前面断开。（请注意，这点不同于Google其他语言的编程风格，比如C++和JavaScript。）
   * 这条规则也适用于如下“类运算符”符号：点分隔符（```.```）、类型界定中的&[=and]（```<T extends Foo & Bar>```）和catch块中的管道符号（```catch (FooException | BarException e```）。
2. 如果断行处是在_赋值运算符_前后，一般情况下是在该运算符后面断开。
   * 这条规则也适用于```foreach```语句的分号。
3. 方法或者构造函数与其后的左括号（```(```）留在同一行。
4. 逗号（```,```）与其前面的内容留在同一行。

__4.5.2  换行时缩进至少+4空格__

换行时，第一行后的每一行至少比它的前一行多缩进8个空格。

当有多个连续换行时，缩进可能会多于+8个空格。对于两个连续换行，当且仅当它们是以同级语法元素开始时，使用相同的缩进。

4.5.3 水平对齐一节提到了，不建议用可变的空格数来与前一行对齐。

<a name="406"> </a>
#### 4.6 空白

__4.6.1  垂直空白__

以下情况需要使用一个空行：
1. 连续的类成员之间：字段、初始化函数、方法、嵌套类、静态初始化块、实例初始化块。
   *__例外：__两个连续字段之间的空行是可选的，用于字段的空行主要用来对字段进行逻辑分组。
2. 在方法体内，用于对语句进行逻辑分组
3. 类内的第一个成员前或最后一个成员后使用空行是可选的(既不鼓励也不反对这样做，视个人喜好而定)。
4. 要满足本文档中其他节的空行要求(比如3.3节 import语句)

多个连续的空行是允许的，但不要求这样做(我们也不鼓励这样做)。

__4.6.2  水平空白__

除了编程语言或编程风格规则要求，以及在文本、注释和Javadoc中，单个ASCII空格仅在以下几个地方出现：
1. 分隔任何保留字与紧随其后的左括号(```(```)(如```if```, ```for```或```catch```等)。
2. 分隔任何保留字与其前面的右大括号(```}```)(如```else```, ```catch```)。
3. 在任何左大括号前({)，两个例外：
   * ```@SomeAnnotation({a, b})```（不需要空格）
   * ```String[][] x = {{"foo"}};```（```{{```之间不需要空格，见条目8下面的提示）
4. 在任何二元或三元运算符的两侧。这也适用于以下“类运算符”符号：
   * 类型界限中的&(```<T extends Foo & Bar>```)
   * 处理多个异常的catch块中的管道符号|(```catch (FooException | BarException e)```)
   * ```foreach```语句中的分号```:```
5. 在```,:;```或者the closing parenthesis (```)```) of a cast之后
6. 在句尾注释时，双斜线（```//```）的两侧都需要使用空格。这里可以允许多个空格，但没有必要。
7. 类型和变量之间：```List<String> list```
8. 数组初始化中，大括号内的空格是可选的
   * ```new int[] {5, 6}```和```new int[] { 5, 6 }```都是可以的。
>__Note：__这个规则并不要求或禁止在行的开头或结尾处需要额外的空格，只对内部空格做要求

__4.6.2  水平对齐：不作要求__

__术语说明：__水平对齐是指为了使个别元素与其前一行的相应元素对齐而在代码中添加额外不固定数目的空格的行为。

这是允许的，但这在Google风格中是不被要求的。即使对于已经使用水平对齐的代码，我们也不要求保持这种风格。
这里有个不对齐以及对齐后的例子：
```java
private int x; // this is fine
private Color color; // this too

private int   x;      // permitted, but future edits
private Color color;  // may leave it unaligned
```
>对齐有助于增加代码可读性，但是也带来了后续代码维护的问题。假设将来只需要更改一行代码的情况。
这可能导致原本很漂亮的对齐代码变得错位，这是允许的。更多时候会促使程序员在周围代码行中调整空格数，而这有可能导致一系列的格式重排。
最坏的情况下，这会带来无用功，即使是在最好的情况下，也会扰乱代码的历史版本信息，使得重审的效率变低并使代码合并冲突的问题更严重。

<a name="407"> </a>
#### 4.7 用于分组的小括号：建议

仅当代码作者和评审人员认为不使用分组小括号代码也不会使得代码被误解或者使用了分组小括号也不会使得代码更容易被理解时，才可以去掉可用可不用的小括号。假设所有的读者都能记住整个Java的运算符优先级表是不合情理的。

<a name="408"> </a>
#### 4.8 特定结构体

__4.8.1  枚举类__

在紧跟枚举常量的逗号之后，可用分行符。

对于没有方法和对常量的说明文档的枚举类，可写成数组初始化的格式（见4.8.3.1节 数组初始化）
```private enum Suit { CLUBS, HEARTS, SPADES, DIAMONDS }```
由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。

__4.8.2  变量声明__

__4.8.2.1 每次只声明一个变量__

每一次变量声明仅声明一个变量：不要使用类似于```int a,b;```的语句。

__4.8.2.2 需要时才声明，并尽快进行初始化__

局部变量并非习惯性地在代码块的开头就进行声明。反而，变量声明往往与第一次使用该变量的代码相近，从而减小变量的作用域。局部变量在声明时直接初始化，或者声明后尽快进行初始化。

__4.8.3  数组__

__4.8.3.1 数组初始化：可写成块状结构__

数组初始化可以写成块状结构，比如，下面的写法都是可行的（未穷举）：

```java
new int[] {
  0, 1, 2, 3 
}

new int[] {
  0,
  1,
  2,
  3
}

new int[] {
  0, 1,
  2, 3
}

new int[]{0, 1, 2, 3}
```

__4.8.3.2 非C风格的数组声明__

中括号是变量类型的一部分：```String[] args```， 而非```String args[]```。

__4.8.4  switch语句__

__术语说明：__switch块的大括号内是一个或多个语句组。每个语句组包含一个或多个switch标签(```case FOO:```或```default:```)，后面跟着一条或多条语句。
__4.8.4.1 缩进__

与其它块状结构一致，switch块中的内容缩进为4个空格。
每个switch标签后新起一行，再缩进4个空格，写下一条或多条语句。随后的switch标签回到之前的缩进级别。

__4.8.4.2 Fall-through：注释__

在一个switch块内，每个语句组要么通过```break```, ```continue```, ```return```或抛出异常来终止，要么通过一条注释来说明程序将继续执行到下一个语句组， 任何能表达这个意思的注释都是OK的(典型的是用```// fall through```)。这个特殊的注释并不需要在最后一个语句组(一般是```default```)中出现。示例：
```java
switch (input) {
  case 1:
  case 2:
    prepareOneOrTwo();
    // fall through
  case 3:
    handleOneTwoOrThree();
    break;
  default:
    handleLargeNumber(input);
}
```
__4.8.4.3 写出default的情况__

每个switch语句都应包含一个```default```语句组，即使它什么代码也不包含。

__4.8.5  注解__

类、方法和构造函数上的注解应该紧跟在文档块之后，每个注解独占一行。
这些换行不属于自动换行(4.5节，自动换行)，因此缩进级别不变。示例：
```
@Override
@Nullable
public String getNameIfPresent() { ... }
```
__例外：__单个无参数的注解可以和函数签名放在同一行：
```
@Override public int hashCode() { ... }
```
类成员上的注解也要紧跟在文档块之后，但是这种情况下，多个注解可以放在同一行；比如：
```
@Partial @Mock DataLoader loader;
```
参数和局部变量注解格式化没有特定规则。

__4.8.6  注释__

__4.8.6.1 块注释风格__

块注释与其周围的代码在同一缩进级别。它们可以是```/* ... */```风格，也可以是```// ...```风格。对于多行的```/* ... */```注释，后续行必须从\*开始， 并且与前一行的\*对齐。以下示例注释都是OK的
```
/*
 * This is          // And so           /* Or you can
 * okay.            // is this.          * even do this. */
 */
```
不要把注释框在由星号或其它字符绘制的框格里。
>Tip：在写多行注释时，如果你希望在必要时能自动换行(即注释像段落风格一样)，那么使用```/* ... */```。大多数的格式化工具不支持对```// ...```重新换行

__4.8.7  修饰符（Modifiers）__

类和成员的modifiers如果存在，则按Java语言规范中推荐的顺序出现。
```public protected private abstract static final transient volatile synchronized native strictfp```

__4.8.8  数常量__

```long```型整数使用```L```后缀，而非小写```l```。比如，```3000000000L``` 而不是 ```3000000000l```。

<a name="5"> </a>
## 5 命名

<a name="501"> </a>
#### 5.1 对所有标识符都通用的规则
标识符只能使用ASCII字母和数字，因此每个有效的标识符名称都能匹配正则表达式\w+。另外，在下述的两种情况下，还可以使用下划线。
在Google其它编程语言风格中使用的特殊前缀或后缀，如```name_```, ```mName```, ```s_name```和```kName```，在Java编程风格中都不再使用。

<a name="502"> </a>
#### 5.2 各个标识符类型各自的规则
__5.2.1  包名__

包名全部小写，连续的单词只是简单地连接起来，不使用下划线。比如，```com.example.deepspace```, 既不是```com.example.deepSpace```也不是```com.example.deep_space```。

__5.2.2  类名__

类名依据```UpperCamelCase```风格。
类名通常是名词或者是名词词组。比如，```Character```或者是```ImmutableList```。接口名称有时可能是形容词或形容词短语（比如，```Readable```）。
目前还没有特定的或者是完备的规则可以用于注解命名。
测试类的命名要以被测试的类的名字开头，以```Test```结尾。比如，```HashTest```或者是```HashIntegrationTest```

__5.2.3  方法名__

类名依据```lowerCamelCase```风格。

方法名通常是动词或者动词词组。比如，```sendMessage```或者是```stop```。
下划线可能用于Junit的单元测试方法上用于分隔方法名的各个逻辑组成部分。一个典型的例子是```test<MethodUnderTest>_<state>```，比如，```testPop_emptyStack```。不存在唯一正确的方式来命名测试方法。

__5.2.4  常量名__

常量名命名模式为```CONSTANT_CASE```：字母全部大写，用下划线分隔单词。那，到底什么算是一个常量？
每一个常量都是静态final字段，但不是所有的静态final字段都是常量。
在决定是否使用常量命名模式时，需要先考虑一个字段是否感觉像是常量。比如，任意一个实例的可观测状态会发生改变，那几乎可以肯定它不是常量。仅仅因为不打算去改变一个对象而认为它是常量是不够的。示例：
```java
// 常量
static final int NUMBER = 5;
static final ImmutableList<String> NAMES = ImmutableList.of("Ed", "Ann");
static final Joiner COMMA_JOINER = Joiner.on(',');  // because Joiner is immutable
static final SomeMutableType[] EMPTY_ARRAY = {};
enum SomeEnum { ENUM_CONSTANT }

// 非常量
static String nonFinal = "non-final";
final String nonStatic = "non-static";
static final Set<String> mutableCollection = new HashSet<String>();
static final ImmutableSet<SomeMutableType> mutableElements = ImmutableSet.of(mutable);
static final Logger logger = Logger.getLogger(MyClass.getName());
static final String[] nonEmptyArray = {"these", "can", "change"};
```
常量名通常是名词或者名词词组。

__5.2.5  非常量字段名__

非常量字段名（静态或非静态）依据```lowerCamelCase```风格。
非常量字段名通常是名词或者名词词组。比如，```computedValues```或者```index```。

__5.2.6  参数名__

参数名依据```lowerCamelCase```风格。
参数应该避免用单个字符命名。

__5.2.7  局部变量名__

局部变量名依据```lowerCamelCase```风格，比起其它类型的名称，局部变量名可以有更为宽松的缩写。
局部变量名应该避免用单个字符命名，除非是临时变量或者是循环内的变量。
即使局部变量是final和不可改变的，也不应该把它示为常量，不能按照常量的规则来命名局部变量。

__5.2.8  类型变量名__

类型变量可以选择以下两种命名风格之一：
* 单个大写字母，可以在其后跟一个数字（例如：E, T, X, T2）
* 类名命名形式的名字紧跟一个大写字母T（例如：RequestT, FooBarT）

<a name="503"> </a>
#### 5.3 驼峰式命名法（CamelCase）

有时，我们有不只一种合理的方式将一个英语词组转换成驼峰形式，如缩略语或不寻常的结构(例如"IPv6"或"iOS")。Google给出了如下转换方案。

从名字的散文形式开始：

1. 把短语转换为纯ASCII码，并且移除任何撇号。例如："Müller’s algorithm"将变成"Muellers algorithm"。
2. 把1的结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。
  * 建议：如果某个单词已经有了常用的驼峰表示形式，按其组成成分将其分割开来（比如："AdWird" 变成"ad word"）。需要注意，类似"iOS"这样的单词不是驼峰的命名方式，因此，该推荐对这类词不适用。
3. 现在所有的字母都小写（包括缩写词），并将单词的第一个字母大写：
  * 如果每个单词的第一个字母都大写，可得到大驼峰式命名（```UpperCamelCase```)
  * 如果除了第一个单词，其他单词的第一个字母都大写，可得到小驼峰式命名（```LowerCamelCase```）
4. 最后将所有的单词连接起来得到一个标识符。

示例：

| 散文形式 | 正确的命名方式  | 错误的命名方式 |
| :--------|:----------------|:---------------|
|"XML HTTP request"        |XmlHttpRequest                   |XMLHTTPRequest|
|"new customer ID"         |newCustomerId                    |newCustomerID|
|"inner stopwatch"         |innerStopwatch                   |innerStopWatch|
|"supports IPv6 on iOS?"   |supportsIpv6OnIos                |supportsIPv6OnIOS|
|"YouTube importer"        |YouTubeImporter/YoutubeImporter* ||

加星号处表示可以，但不推荐。
>英语中有一些单词连接得比较含糊：比如"nonempty"和"non-empty"都是正确的，因此函数命名checkNonempty和checkNonEmpty也都是正确的。

<a name="6"> </a>
## 6 编程实践

<a name="601"> </a>
#### 6.1 @Override：总是使用

只要是合法的，就应该使用```@Override```注解。包括子类方法覆盖父类的方法、子类实现一个接口方法以及接口方法重新指定父接口的方法。

__例外：__当父类方法标有```@Deprecated```时，可省略```@Override```。

<a name="602"> </a>
#### 6.2 捕获的异常：不能忽视

除了下列的情况，对捕获的异常不做响应极有可能是错误的。(一般的处理方式是打日志，或者如果它被认为是不可能的，则把它当作一个```AssertionError```重新抛出。)

如果确实不需要在catch块中做任何响应，需要在注释中说明这样做是合理的。

```java
try {
  int i = Integer.parseInt(response);
  return handleNumericResponse(i);
} catch (NumberFormatException ok) {
  // it's not numeric; that's fine, just continue
}
return handleTextResponse(response);
```

__例外：__在测试中，如果一个异常被命名为```expected```，则可以不做注释忽略它。如下是一个常用的语法，用于明确我们所测试的方法确实会抛出我们所期望的异常类型，因此这里不需要注释。

```java
try {
  emptyStack.pop();
  fail();
} catch (NoSuchElementException expected) {
}
```

<a name="603"> </a>
#### 6.3 静态成员：使用类进行调用

当我们需要调用一个类的静态成员时，应该使用类名，而不是该类的对象或者是该类类型的表达式。

```java
Foo aFoo = ...;
Foo.aStaticMethod(); // good
aFoo.aStaticMethod(); // bad
somethingThatYieldsAFoo().aStaticMethod(); // very bad
```

<a name="604"> </a>
#### 6.4 Finalizer：禁用

我们极少会去覆盖```Object.finalize```。
>Tip：不要使用finalize。如果你非要使用它，请先仔细阅读和理解Effective Java 第7条款：“Avoid Finalizers”，然后不要使用它。

<a name="7"> </a>
## 7 Javadoc

<a name="701"> </a>
#### 7.1 格式

__7.1.1  基本格式__

Javadoc的基本格式如下所示：
```java
/**
 * Multiple lines of Javadoc text are written here,
 * wrapped normally...
 */
public int method(String p1) { ... }
```
或者是以下单行形式：
```
/** An especially short bit of Javadoc. */
```
基本格式总是可以被接受的。当整个Javadoc块能容纳于一行时且没有Javadoc标记@XXX，可以使用单行形式。

__7.1.2  段落__

空行（即，只包含最左侧星号的行）会出现在段落之间和Javadoc标记(@XXX)之前(如果有的话)。除了第一个段落外的其他段落，第一个单词前必须带有```<p>```，两者之间么有空格。

__7.1.3  @语句__

标准的Javadoc @语句按以下顺序出现：```@param```, ```@return```, ```@throws```, ```@deprecated```, 前面这4种标记如果出现，描述都不能为空。 当描述无法在一行中容纳，连续行需要至少再缩进4个空格。

<a name="702"> </a>
#### 7.2 总结片段

每个类或成员的Javadoc以一个简短的摘要片段开始。该片段非常重要，这是文本中唯一会出现在特定的情形中的部分，比如作为类和成员的索引。

该片段是名词词组或者是动词词组，不是一个完整的句子。它不会以```A {@code Foo} is a...```或```This method returns...```开头, 它也不会是一个完整的祈使句，如```Save the record...```。尽管该片段开头大写且用标点符号结尾使得它看起来像一个句子。

>一个常见的错误是以```/** @return the customer ID */```这样的格式来写简单的Javadoc。应该改为```/** Returns the customer ID. */```。

<a name="703"> </a>
#### 7.3 哪里需要使用Javadoc

至少需要为每一个公共类、类的每一个```public```或者是```protected```成员编写Javadoc，除了以下所列的几种例外。

其他的类或者类成员在需要的时候也可以编写Javadoc，

__7.3.1  例外：自解释的方法__

对于简单易了解的方法如```getFoo```，Javadoc是可选的，这种情况下除了写“Returns the foo”，确实也没有什么值得写了。

>__重要：__如果有读者需要知道的相关信息，那么这种例外情况不应作为省略Javadoc的理由。比如，对于```getCanonicalName```，如果不做文档注释，读者很可能不知道"canonical name"是什么意思！

__7.3.1  例外：override__

不需要为每一个覆盖了超类方法的方法写Javadoc（按需即可）。

<a name="8"> </a>
## 8 样例
