# Java内存模型

硬件效率 -> 多核cpu+多级缓存（并发和优化操作） -> 一致性问题(当读，写和检查共享变量时出现race condition)

![image](https://github.com/mvpanda/projects/blob/master/java/imgs/jmm.png)

## 定义

Java内存模型描述的是一组规则或规范，通过这组规范定义了程序中线程对各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式，来达到屏蔽掉各种硬件和操作系统的内存差异而在各种平台下能保证一致的内存访问效果。

## Java内存模型的承诺
`原子性`：一个操作是不可中断的，即使是在多线程环境下，一个操作一旦开始就不会被其他线程影响。（“半个变量”：对于32位系统，long和double类型数据操作不是原子性的）

`可见性`：多线程环境下，一个线程对内存的操作是否可被其他线程马上看到。

`有序性`：维持顺序化语义，即程序的最终结果等同于它在严格的顺序化环境下的结果

## 保障方式
1. `JVM自身提供的对基本数据类型读写操作的原子性`
2. `8个内存基本操作`（主内存与工作内存之间具体的交互协议）：

|指令|名称|含义|
|:---|:---|:---|
|lock|锁定 |@主内存的变量，把变量标识为一个线程独占的状态|
|unLock|解锁 |@主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定|
|read|读取 |@主内存的变量，把一个变量的值从主内存中读取到线程工作内存中，以便随后的load动作使用|
|load|载入 |@工作内存中的变量，把read操作从主内存中得到的变量值放入工作内存中的变量副本中|
|use|使用 |@工作内存的变量，把工作内存中一个变量的值传递给执行引擎|
|assign|赋值 |@工作内存的变量，把执行引擎接收到的值付给工作内存的变量|
|store|存储 |@工作内存的变量，把工作内存中的一个变量的值传递到主内存中，以便随后的write操作使用|
|write|写入 |@主内存的变量，把store操作从工作内存中得到的变量的值放入主内存的变量中|


如果要把一个变量从主内存复制到工作内存，就要顺序地执行read和load操作，如果把变量从工作内存同步回主内存，就要顺序地执行store和write操作。Java内存模型还规定了在执行上述8种基本操作必须满足如下规则：
    
　　a. 不允许read和load。store和write操作之一单独出现。
  
　　b. 不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。
  
　　c. 不允许一个线程无原因的把数据从线程的工作内存同步回主内存。
  
　　d. 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用了一个未被初始化的变量，换句话说，就是一个变量实施use、store操作之前，必须先执行过了assign和load操作。
  
　　e. 一个变量在同一个时刻只允许一个线程对其进行lock操作，但lock操作可以被同一条操作重复执行多次，多次执行lock之后，只有执行相同次数的unlock操作，变量才会被解锁。
  
　　f. 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新load和assign操作初始化变量的值。
  
　　g. 如果一个变量实现没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去lock一个被其他线程锁定住的变量。
  
　　h. 对一个变量执行unlock操作之前，必须先把此变量同步回主内存中。

3. 更高层次的字节码指令monitorenter和monitorexit -> `synchronized`
4. `重入锁(ReentrantLock)`
5. `volatile`:

   volatile保证了可见性，但是不具备原子特性，原因（Memory Barrier）：
   
   从heap(jmm)|主内存(计算机结构)直接读、写；禁止指令重排序
   
   单独使用 volatile 还不足以实现计数器、互斥锁或任何具有与多个变量相关的不变式（Invariants）的类（例如 “start <=end”）。只能在有限的一些情形下使用 volatile 变量替代锁：1. 对变量的写操作不依赖于当前值或者单一写线程；2. 该变量没有包含在具有其他变量的不变式中（禁止指令重排序）；


>>>内存屏障，又称内存栅栏，是一个CPU指令，它的作用有两个，一是保证特定操作的执行顺序，二是保证某些变量的内存可见性。


6. `happens-before 原则（8个）`：happens-before规则不是描述实际操作的先后顺序，它是用来描述可见性的一种规则，如果a happens-before b，那么a及之前的写操作在另一个线程t2进行了b操作时都对t2可见。

|规则|说明|
|:---|:---|
|程序次序执行规则|在一个线程内，按照代码顺序执行，前面的操作先行发生于书写在后面的操作|
|管程锁定规则|一个unlock操作先行发生于后面（时间上的先后）对同一个锁的lock操作|
|volatile变量规则|对于一个volatile变量的写操作先行发生于后面对这个变量的读操作|
|线程启动规则|Thread对象的start()方法先行发生于此线程的每一个动作|
|线程终止规则|线程的所有操作都先行发生于对此线程的终止操作|
|线程中断规则|对线程interrupt（）方法的调用先行发生于被中断线程的代码检测到中断时间的发生|
|对象终结规则|一个对象的初始化完成先行发生于它的finalize（）方法的开始|
|传递性|若A先行于B发生，B先行于C，那么得出A先行于C|
  
